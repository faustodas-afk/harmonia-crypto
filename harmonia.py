#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
╔═══════════════════════════════════════════════════════════════════════════════╗
║                              HARMONIA v2.1                                     ║
║                                                                                ║
║         A Cryptographic Hash Function Based on the Golden Ratio                ║
║              and Temporal Quasicrystal Structures                              ║
║                                                                                ║
║  Inspired by: Dumitrescu et al., Nature 607, 463-467 (2022)                   ║
║  "Dynamical topological phase realized in a trapped-ion quantum simulator"    ║
╚═══════════════════════════════════════════════════════════════════════════════╝

HARMONIA produces a 256-bit cryptographic hash using principles derived from:
    1. The Golden Ratio (φ = 1.618...)
    2. Fibonacci sequences and quasi-periodic patterns
    3. Temporal quasicrystal structures
    4. Edge protection mechanisms from topological quantum systems

SECURITY NOTICE:
    This algorithm is an experimental research proposal. It has NOT undergone
    formal cryptanalysis and should NOT be used for security-critical applications.
    Use SHA-256 or SHA-3 for production systems.

Usage:
    from harmonia import harmonia, harmonia_hex
    
    digest = harmonia(b"Hello, World!")
    hex_digest = harmonia_hex(b"Hello, World!")

Author: [Your Name]
License: MIT
Version: 2.2
Date: January 2026
"""

import struct
from typing import List, Tuple

__version__ = "2.2"
__all__ = ["harmonia", "harmonia_hex", "BLOCK_SIZE", "DIGEST_SIZE"]

# ═══════════════════════════════════════════════════════════════════════════════
# ALGORITHM PARAMETERS
# ═══════════════════════════════════════════════════════════════════════════════

BLOCK_SIZE = 64      # 512 bits
DIGEST_SIZE = 32     # 256 bits
WORD_SIZE = 4        # 32 bits
NUM_ROUNDS = 64
STATE_WORDS = 8

# ═══════════════════════════════════════════════════════════════════════════════
# MATHEMATICAL CONSTANTS
# ═══════════════════════════════════════════════════════════════════════════════

# Golden ratio and its reciprocal
PHI = 1.6180339887498948482045868343656381177203091798057628621354486227
PHI_RECIPROCAL = 0.6180339887498948482045868343656381177203091798057628621354486227

# Extended Fibonacci sequence for rotations
FIBONACCI = (1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144)

# ═══════════════════════════════════════════════════════════════════════════════
# OPTIMIZED CONSTANTS (Hamming weight ≈ 16)
# 
# Derived from powers of φ and Fibonacci continued fractions.
# Optimized for balanced bit distribution (approximately 50% ones).
# ═══════════════════════════════════════════════════════════════════════════════

PHI_CONSTANTS = (
    0x9E37605A,  # [ 0] Hamming: 16
    0xDAC1E0F2,  # [ 1] Hamming: 16
    0xF287A338,  # [ 2] Hamming: 16
    0xFA8CFC04,  # [ 3] Hamming: 16
    0xFD805AA6,  # [ 4] Hamming: 16
    0xCCF29760,  # [ 5] Hamming: 16
    0xFF8184C3,  # [ 6] Hamming: 16
    0xFF850D11,  # [ 7] Hamming: 16
    0xCC32476B,  # [ 8] Hamming: 16
    0x98767486,  # [ 9] Hamming: 15
    0xFFF82080,  # [10] Hamming: 15
    0x30E4E2F3,  # [11] Hamming: 16
    0xFCC3ACC1,  # [12] Hamming: 17
    0xE5216F38,  # [13] Hamming: 16
    0xF30E4CC9,  # [14] Hamming: 16
    0x948395F6,  # [15] Hamming: 16
)

RECIPROCAL_CONSTANTS = (
    0x7249217F,  # [ 0] Hamming: 16
    0x5890EB7C,  # [ 1] Hamming: 16
    0x4786B47C,  # [ 2] Hamming: 16
    0x4C51DBE8,  # [ 3] Hamming: 16
    0x4E4DA61B,  # [ 4] Hamming: 16
    0x4F76650C,  # [ 5] Hamming: 16
    0x4F2F1A2A,  # [ 6] Hamming: 16
    0x4F6CE289,  # [ 7] Hamming: 16
    0x4F1ADF40,  # [ 8] Hamming: 16
    0x4E84BABC,  # [ 9] Hamming: 16
    0x4F22D993,  # [10] Hamming: 16
    0x497FA704,  # [11] Hamming: 16
    0x4F514F19,  # [12] Hamming: 16
    0x4E8F43B8,  # [13] Hamming: 16
    0x508E2FD9,  # [14] Hamming: 16
    0x4B5F94A4,  # [15] Hamming: 16
)

# Pre-computed Fibonacci word for 64 rounds (quasi-periodic pattern)
# Generated by: S(n) = S(n-1) + S(n-2), with S(0)="B", S(1)="A"
FIBONACCI_WORD = "ABAABABAABAABABAABABAABAABABAABAABABAABABAABAABABAABAABABAABABAAB"

# Pre-computed quasicrystal rotation table
# Eliminates floating-point dependency for cross-platform determinism
# Generated from: rotation = floor(|r * cos(θ + i * ψ)| * 13) mod 21 + 1
# where θ = round * φ * π, r = FIBONACCI[round mod 12], ψ = φ - 1
QUASICRYSTAL_ROTATIONS = (
    (14, 11, 5, 4, 11, 13, 11, 5, 3, 10),  # round 0
    (5, 11, 13, 11, 4, 5, 11, 13, 11, 5),  # round 1
    (20, 6, 11, 2, 5, 21, 7, 10, 1, 5),  # round 2
    (14, 18, 7, 7, 17, 14, 18, 9, 9, 15),  # round 3
    (6, 12, 18, 1, 3, 10, 9, 16, 2, 6),  # round 4
    (16, 2, 6, 14, 13, 18, 6, 11, 10, 11),  # round 5
    (19, 15, 14, 17, 3, 12, 12, 16, 2, 12),  # round 6
    (16, 20, 6, 12, 4, 7, 6, 16, 8, 9),  # round 7
    (16, 1, 6, 6, 21, 11, 10, 5, 5, 4),  # round 8
    (14, 16, 16, 5, 12, 19, 11, 10, 21, 2),  # round 9
    (11, 16, 14, 9, 17, 20, 8, 19, 10, 10),  # round 10
    (18, 3, 10, 13, 13, 1, 20, 20, 18, 4),  # round 11
    (4, 5, 11, 13, 11, 5, 4, 11, 13, 11),  # round 12
    (13, 10, 3, 5, 12, 13, 11, 4, 5, 11),  # round 13
    (12, 3, 5, 19, 5, 11, 2, 5, 20, 7),  # round 14
    (5, 5, 20, 15, 18, 7, 6, 18, 14, 18),  # round 15
    (20, 21, 21, 5, 14, 18, 1, 2, 8, 11),  # round 16
    (3, 20, 15, 16, 21, 4, 16, 14, 17, 5),  # round 17
    (10, 6, 10, 1, 16, 13, 14, 1, 15, 13),  # round 18
    (21, 17, 18, 11, 5, 11, 14, 2, 2, 12),  # round 19
    (20, 17, 2, 17, 18, 19, 15, 7, 13, 6),  # round 20
    (21, 1, 7, 7, 5, 18, 19, 19, 13, 1),  # round 21
    (11, 19, 2, 19, 15, 17, 3, 20, 8, 7),  # round 22
    (13, 10, 16, 20, 3, 8, 18, 8, 5, 2),  # round 23
    (12, 13, 10, 4, 5, 11, 13, 11, 4, 5),  # round 24
    (2, 6, 12, 13, 10, 3, 6, 12, 13, 10),  # round 25
    (5, 18, 4, 13, 3, 5, 19, 5, 12, 2),  # round 26
    (1, 16, 17, 5, 4, 20, 15, 18, 6, 6),  # round 27
    (17, 1, 17, 20, 21, 20, 3, 15, 19, 1),  # round 28
    (17, 13, 15, 5, 1, 16, 15, 20, 2, 18),  # round 29
    (1, 10, 19, 8, 3, 14, 4, 17, 12, 11),  # round 30
    (9, 15, 3, 4, 18, 16, 6, 10, 15, 15),  # round 31
    (2, 21, 3, 12, 5, 8, 19, 14, 11, 3),  # round 32
    (1, 15, 17, 1, 14, 14, 21, 15, 19, 12),  # round 33
    (2, 12, 20, 13, 13, 2, 5, 14, 19, 18),  # round 34
    (15, 10, 19, 10, 15, 10, 21, 3, 7, 2),  # round 35
    (10, 3, 6, 12, 13, 10, 3, 6, 12, 13),  # round 36
    (12, 13, 9, 2, 7, 12, 13, 10, 3, 6),  # round 37
    (2, 15, 4, 5, 18, 3, 13, 3, 5, 19),  # round 38
    (16, 2, 1, 2, 16, 17, 4, 3, 21, 15),  # round 39
    (21, 21, 19, 16, 2, 19, 20, 20, 18, 2),  # round 40
    (9, 12, 7, 18, 12, 13, 7, 3, 17, 14),  # round 41
    (21, 3, 14, 5, 13, 20, 7, 21, 17, 6),  # round 42
    (2, 18, 20, 6, 10, 9, 8, 18, 13, 1),  # round 43
    (6, 3, 15, 8, 1, 19, 3, 14, 15, 20),  # round 44
    (6, 1, 5, 8, 8, 5, 1, 6, 1, 15),  # round 45
    (2, 7, 17, 21, 18, 18, 14, 6, 2, 12),  # round 46
    (4, 4, 9, 9, 8, 15, 6, 19, 4, 21),  # round 47
    (7, 12, 13, 10, 2, 6, 12, 13, 10, 3),  # round 48
    (9, 1, 7, 12, 13, 9, 2, 7, 12, 13),  # round 49
    (4, 4, 16, 1, 15, 4, 5, 17, 2, 14),  # round 50
    (3, 4, 17, 16, 2, 1, 2, 16, 17, 3),  # round 51
    (18, 12, 7, 1, 1, 19, 15, 4, 20, 21),  # round 52
    (12, 19, 9, 7, 14, 9, 18, 12, 12, 9),  # round 53
    (3, 17, 21, 21, 1, 11, 8, 15, 20, 5),  # round 54
    (21, 17, 13, 7, 21, 21, 4, 5, 14, 12),  # round 55
    (3, 6, 1, 1, 15, 3, 14, 1, 14, 16),  # round 56
    (15, 21, 15, 14, 1, 17, 15, 1, 14, 1),  # round 57
    (17, 13, 5, 21, 8, 9, 20, 3, 16, 16),  # round 58
    (2, 3, 8, 18, 18, 13, 2, 6, 11, 1),  # round 59
    (13, 9, 1, 7, 12, 13, 9, 2, 7, 12),  # round 60
    (8, 13, 13, 8, 1, 8, 13, 13, 9, 2),  # round 61
    (15, 2, 17, 4, 4, 16, 1, 15, 4, 4),  # round 62
    (18, 15, 20, 4, 5, 17, 16, 1, 2, 3),  # round 63
    (12, 5, 2, 17, 11, 8, 2, 1, 18, 14),  # round 64
    (6, 21, 1, 14, 20, 8, 5, 17, 10, 19),  # round 65
)

# ═══════════════════════════════════════════════════════════════════════════════
# PRIMITIVE OPERATIONS
# ═══════════════════════════════════════════════════════════════════════════════

MASK32 = 0xFFFFFFFF


def _rotr(value: int, amount: int) -> int:
    """32-bit right rotation."""
    amount &= 31
    return ((value >> amount) | (value << (32 - amount))) & MASK32


def _rotl(value: int, amount: int) -> int:
    """32-bit left rotation."""
    amount &= 31
    return ((value << amount) | (value >> (32 - amount))) & MASK32


def _quasicrystal_rotation(round_num: int, state_index: int) -> int:
    """
    Compute rotation amount using quasicrystal projection.

    Projects a 2D quasi-periodic pattern onto 1D, inspired by the
    dimensional projection properties of Penrose tilings and the
    Fibonacci quasicrystal used in Dumitrescu et al.

    Returns rotation in range [1, 21].

    Uses pre-computed lookup table for cross-platform determinism.
    Original formula: floor(|r * cos(θ + i * ψ)| * 13) mod 21 + 1
    where θ = round * φ * π, r = FIBONACCI[round mod 12], ψ = φ - 1
    """
    return QUASICRYSTAL_ROTATIONS[round_num][state_index]


def _penrose_index(n: int) -> int:
    """
    Generate quasi-periodic index based on Penrose tiling projection.
    Used for non-repeating but structured access patterns.
    """
    x = int(n * PHI) & 0xFF
    y = int(n * PHI * PHI) & 0xFF
    return (x ^ y) & 0x1F


# ═══════════════════════════════════════════════════════════════════════════════
# MIXING FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════════════

def _mix_golden(a: int, b: int, k: int, r: int, i: int) -> Tuple[int, int]:
    """
    Golden mixing function (Type A - intensive).
    
    Features:
        - Quasicrystal-based rotations
        - Non-linear mixing simulating "second time dimension"
        - Full diffusion between both inputs
    """
    # Phase 1: Rotation and combination
    rot1 = _quasicrystal_rotation(r, i)
    a = _rotr(a, rot1)
    a = (a + b) & MASK32
    a ^= k
    
    # Phase 2: Complementary rotation
    rot2 = _quasicrystal_rotation(r + 1, i + 1)
    b = _rotl(b, rot2)
    b = (b ^ a) & MASK32
    b = (b + k) & MASK32
    
    # Phase 3: Non-linear mixing (second time dimension effect)
    mix = ((a * 3) ^ (b * 5)) & MASK32
    a = (a ^ (mix >> 11)) & MASK32
    b = (b ^ ((mix << 7) & MASK32)) & MASK32
    
    return a, b


def _mix_complementary(a: int, b: int, k: int, r: int, i: int) -> Tuple[int, int]:
    """
    Complementary mixing function (Type B - light).
    
    Lighter version of golden mix, used in quasi-periodic alternation
    to create the Fibonacci word pattern.
    """
    a = (a ^ b) & MASK32
    a = _rotl(a, _quasicrystal_rotation(r, i))
    a = (a + (k >> 1)) & MASK32
    
    b = (b + a) & MASK32
    b = _rotr(b, _quasicrystal_rotation(r + 1, i + 1))
    b ^= (k >> 1)
    
    return a, b


def _exchange_quasi_periodic(
    golden: List[int], 
    complementary: List[int], 
    r: int, 
    round_type: str
) -> Tuple[List[int], List[int]]:
    """
    Exchange information between dual streams.
    
    Intensity varies based on the quasi-periodic round type,
    mimicking the Fibonacci-patterned laser pulses in the
    quantum coherence experiments.
    """
    g = golden.copy()
    c = complementary.copy()
    
    if round_type == 'A':
        # Intensive exchange
        for i in range(STATE_WORDS):
            pi = _penrose_index(r + i)
            if pi % 3 == 0:
                temp = g[i] ^ c[i]
                g[i] = (g[i] + (temp >> 8)) & MASK32
                c[i] = (c[i] + (temp & 0xFF00)) & MASK32
    else:
        # Light exchange (edges only)
        temp = g[0] ^ c[-1]
        g[0] = (g[0] ^ (temp >> 16)) & MASK32
        c[-1] = (c[-1] ^ (temp & 0xFFFF)) & MASK32
    
    return g, c


def _edge_protection(state: List[int], r: int) -> List[int]:
    """
    Apply additional transformations to edge elements.
    
    Inspired by the topological edge protection observed in
    Dumitrescu et al., where edge qubits showed enhanced
    coherence due to the quasi-periodic driving pattern.
    """
    s = state.copy()
    
    # Left edge protection
    rot_l = _quasicrystal_rotation(r, 0)
    s[0] = _rotr(s[0], rot_l)
    fib_const = (FIBONACCI[r % 12] * 0x9E3779B9) & MASK32
    s[0] ^= fib_const
    
    # Right edge protection  
    rot_r = _quasicrystal_rotation(r, STATE_WORDS - 1)
    s[-1] = _rotl(s[-1], rot_r)
    s[-1] ^= (fib_const ^ MASK32)
    
    # Edge interaction (entanglement simulation)
    interaction = (s[0] ^ s[-1]) >> 16
    s[0] = (s[0] + interaction) & MASK32
    s[-1] = (s[-1] + interaction) & MASK32
    
    return s


# ═══════════════════════════════════════════════════════════════════════════════
# CORE ALGORITHM
# ═══════════════════════════════════════════════════════════════════════════════

def _pad_message(message: bytes) -> bytes:
    """
    Apply Merkle-Damgård padding.
    
    Appends bit '1', then zeros, then 64-bit length (big-endian).
    Final length is multiple of 512 bits.
    """
    length_bits = len(message) * 8
    
    padded = bytearray(message)
    padded.append(0x80)
    
    while (len(padded) + 8) % BLOCK_SIZE != 0:
        padded.append(0x00)
    
    padded.extend(struct.pack('>Q', length_bits))
    
    return bytes(padded)


def _init_state() -> Tuple[List[int], List[int]]:
    """Initialize dual state vectors from constants."""
    return list(PHI_CONSTANTS[:STATE_WORDS]), list(RECIPROCAL_CONSTANTS[:STATE_WORDS])


def _compress(
    block: bytes, 
    state_g: List[int], 
    state_c: List[int]
) -> Tuple[List[int], List[int]]:
    """
    Compress one 512-bit block into the state.
    
    This is the core compression function implementing:
        - Message schedule expansion with quasicrystal rotations
        - 64 rounds with Fibonacci word scheduling (A/B types)
        - Dual-stream processing with periodic exchange
        - Edge protection every 8 rounds
    """
    # Parse block into 16 words
    words = list(struct.unpack('>16I', block))
    
    # Expand to 64 words using quasicrystal rotations
    for idx in range(16, NUM_ROUNDS):
        w1 = words[idx - 2]
        w2 = words[idx - 7]
        w3 = words[idx - 15]
        w4 = words[idx - 16]
        
        rot1 = _quasicrystal_rotation(idx, 0)
        rot2 = _quasicrystal_rotation(idx, 1)
        shift = (_penrose_index(idx) & 0xF) + 1
        
        new_word = (
            _rotr(w1, rot1) ^
            _rotl(w2, rot2) ^
            (w3 >> shift) ^
            w4
        ) & MASK32
        
        words.append(new_word)
    
    # Working state
    g = state_g.copy()
    c = state_c.copy()
    
    # 64 rounds with quasi-periodic scheduling
    for r in range(NUM_ROUNDS):
        round_type = FIBONACCI_WORD[r]
        
        i = r & 7  # r % 8
        j = (r + FIBONACCI[r % 12]) & 7
        
        if round_type == 'A':
            # Golden round (intensive)
            g[i], g[j] = _mix_golden(g[i], g[j], PHI_CONSTANTS[r & 15], r, i)
            g[i] = (g[i] + words[r]) & MASK32
            
            c[i], c[j] = _mix_golden(c[i], c[j], RECIPROCAL_CONSTANTS[r & 15], r, i)
            c[j] = (c[j] + words[63 - r]) & MASK32
        else:
            # Complementary round (light)
            g[i], g[j] = _mix_complementary(g[i], g[j], PHI_CONSTANTS[r & 15], r, i)
            g[j] = (g[j] + words[r]) & MASK32
            
            c[j], c[i] = _mix_complementary(c[j], c[i], RECIPROCAL_CONSTANTS[r & 15], r, j)
            c[i] = (c[i] + words[63 - r]) & MASK32
        
        # Stream exchange
        g, c = _exchange_quasi_periodic(g, c, r, round_type)
        
        # Edge protection every 8 rounds
        if (r & 7) == 7:
            g = _edge_protection(g, r)
            c = _edge_protection(c, r)
    
    # Add to original state (Davies-Meyer construction)
    new_g = [(state_g[i] + g[i]) & MASK32 for i in range(STATE_WORDS)]
    new_c = [(state_c[i] + c[i]) & MASK32 for i in range(STATE_WORDS)]
    
    return new_g, new_c


def _finalize(state_g: List[int], state_c: List[int]) -> bytes:
    """
    Finalize hash by merging dual streams.
    
    Applies final edge protection and fuses the golden and
    complementary streams through XOR with quasicrystal rotations.
    """
    # Final edge protection
    g = _edge_protection(state_g, NUM_ROUNDS)
    c = _edge_protection(state_c, NUM_ROUNDS + 1)
    
    # Fuse streams
    digest_words = []
    for i in range(STATE_WORDS):
        rot = _quasicrystal_rotation(i, i)
        
        g_rot = _rotr(g[i], rot)
        c_rot = _rotl(c[i], rot)
        
        fused = g_rot ^ c_rot
        fused = (fused + PHI_CONSTANTS[i] + (_penrose_index(i) * 0x01010101)) & MASK32
        
        digest_words.append(fused)
    
    return b''.join(struct.pack('>I', w) for w in digest_words)


# ═══════════════════════════════════════════════════════════════════════════════
# PUBLIC API
# ═══════════════════════════════════════════════════════════════════════════════

def harmonia(message: bytes) -> bytes:
    """
    Compute the HARMONIA hash of a message.
    
    Args:
        message: Input bytes to hash
        
    Returns:
        32-byte (256-bit) digest
        
    Example:
        >>> harmonia(b"Hello, World!").hex()
        '...'
    """
    if not isinstance(message, (bytes, bytearray)):
        raise TypeError("message must be bytes or bytearray")
    
    padded = _pad_message(message)
    state_g, state_c = _init_state()
    
    for i in range(0, len(padded), BLOCK_SIZE):
        block = padded[i:i + BLOCK_SIZE]
        state_g, state_c = _compress(block, state_g, state_c)
    
    return _finalize(state_g, state_c)


def harmonia_hex(message: bytes) -> str:
    """
    Compute the HARMONIA hash and return as hexadecimal string.
    
    Args:
        message: Input bytes to hash
        
    Returns:
        64-character hexadecimal string
        
    Example:
        >>> harmonia_hex(b"Hello, World!")
        '...'
    """
    return harmonia(message).hex()


# ═══════════════════════════════════════════════════════════════════════════════
# TEST VECTORS AND SELF-TEST
# ═══════════════════════════════════════════════════════════════════════════════

TEST_VECTORS = {
    b"": "3acc512691bd37d475cec1695d99503b4a3401aa9366b312951ba200190bfe3d",
    b"Harmonia": "5aa5b3bf63ed5d726288f05da3b9ecc419216b260cc780e2435dddf9bf593257",
    b"The quick brown fox jumps over the lazy dog": "39661e930dae99563e597b155d177e331d3016fa65405624c3b2159b9c86b4aa",
}


def self_test() -> bool:
    """
    Run self-test to verify implementation correctness.
    
    Returns:
        True if all tests pass, False otherwise
    """
    print("HARMONIA v{} Self-Test".format(__version__))
    print("=" * 60)
    
    all_passed = True
    
    # Test vectors
    for msg, expected in TEST_VECTORS.items():
        computed = harmonia_hex(msg)
        display_msg = msg.decode('utf-8', errors='replace')[:40] if msg else "(empty)"
        
        if expected is None:
            print(f"  {display_msg}")
            print(f"    -> {computed}")
        elif computed == expected:
            print(f"  ✓ {display_msg}")
        else:
            print(f"  ✗ {display_msg}")
            print(f"    Expected: {expected}")
            print(f"    Got:      {computed}")
            all_passed = False
    
    # Avalanche test
    print("\nAvalanche Test:")
    msg1 = b"test"
    msg2 = b"tess"
    h1 = harmonia(msg1)
    h2 = harmonia(msg2)
    
    diff_bits = sum(bin(a ^ b).count('1') for a, b in zip(h1, h2))
    pct = diff_bits / 256 * 100
    
    print(f"  'test' vs 'tess': {diff_bits}/256 bits differ ({pct:.1f}%)")
    
    if 45 <= pct <= 55:
        print("  ✓ Avalanche effect OK")
    else:
        print("  ✗ Avalanche effect out of range")
        all_passed = False
    
    print("=" * 60)
    print("Result:", "PASS" if all_passed else "FAIL")
    
    return all_passed


# ═══════════════════════════════════════════════════════════════════════════════
# MAIN
# ═══════════════════════════════════════════════════════════════════════════════

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1:
        # Hash command line argument
        message = sys.argv[1].encode('utf-8')
        print(harmonia_hex(message))
    else:
        # Run self-test
        self_test()
